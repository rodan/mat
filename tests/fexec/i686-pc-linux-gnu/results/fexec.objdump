
build/fexec:     file format elf32-i386


Disassembly of section .init:

00000bac <_init>:
 bac:	53                   	push   %ebx
 bad:	83 ec 08             	sub    $0x8,%esp
 bb0:	e8 fb 01 00 00       	call   db0 <__x86.get_pc_thunk.bx>
 bb5:	81 c3 9b 33 00 00    	add    $0x339b,%ebx
 bbb:	8b 83 7c 00 00 00    	mov    0x7c(%ebx),%eax
 bc1:	85 c0                	test   %eax,%eax
 bc3:	74 05                	je     bca <_init+0x1e>
 bc5:	e8 f6 00 00 00       	call   cc0 <__gmon_start__@plt>
 bca:	83 c4 08             	add    $0x8,%esp
 bcd:	5b                   	pop    %ebx
 bce:	c3                   	ret    

Disassembly of section .plt:

00000bd0 <__snprintf_chk@plt-0x10>:
 bd0:	ff b3 04 00 00 00    	pushl  0x4(%ebx)
 bd6:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
 bdc:	00 00                	add    %al,(%eax)
	...

00000be0 <__snprintf_chk@plt>:
 be0:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
 be6:	68 00 00 00 00       	push   $0x0
 beb:	e9 e0 ff ff ff       	jmp    bd0 <_init+0x24>

00000bf0 <__vfprintf_chk@plt>:
 bf0:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)
 bf6:	68 08 00 00 00       	push   $0x8
 bfb:	e9 d0 ff ff ff       	jmp    bd0 <_init+0x24>

00000c00 <mprotect@plt>:
 c00:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)
 c06:	68 10 00 00 00       	push   $0x10
 c0b:	e9 c0 ff ff ff       	jmp    bd0 <_init+0x24>

00000c10 <fflush@plt>:
 c10:	ff a3 18 00 00 00    	jmp    *0x18(%ebx)
 c16:	68 18 00 00 00       	push   $0x18
 c1b:	e9 b0 ff ff ff       	jmp    bd0 <_init+0x24>

00000c20 <_exit@plt>:
 c20:	ff a3 1c 00 00 00    	jmp    *0x1c(%ebx)
 c26:	68 20 00 00 00       	push   $0x20
 c2b:	e9 a0 ff ff ff       	jmp    bd0 <_init+0x24>

00000c30 <memcpy@plt>:
 c30:	ff a3 20 00 00 00    	jmp    *0x20(%ebx)
 c36:	68 28 00 00 00       	push   $0x28
 c3b:	e9 90 ff ff ff       	jmp    bd0 <_init+0x24>

00000c40 <memcmp@plt>:
 c40:	ff a3 24 00 00 00    	jmp    *0x24(%ebx)
 c46:	68 30 00 00 00       	push   $0x30
 c4b:	e9 80 ff ff ff       	jmp    bd0 <_init+0x24>

00000c50 <__stack_chk_fail@plt>:
 c50:	ff a3 28 00 00 00    	jmp    *0x28(%ebx)
 c56:	68 38 00 00 00       	push   $0x38
 c5b:	e9 70 ff ff ff       	jmp    bd0 <_init+0x24>

00000c60 <sysconf@plt>:
 c60:	ff a3 2c 00 00 00    	jmp    *0x2c(%ebx)
 c66:	68 40 00 00 00       	push   $0x40
 c6b:	e9 60 ff ff ff       	jmp    bd0 <_init+0x24>

00000c70 <__cxa_finalize@plt>:
 c70:	ff a3 30 00 00 00    	jmp    *0x30(%ebx)
 c76:	68 48 00 00 00       	push   $0x48
 c7b:	e9 50 ff ff ff       	jmp    bd0 <_init+0x24>

00000c80 <fwrite@plt>:
 c80:	ff a3 34 00 00 00    	jmp    *0x34(%ebx)
 c86:	68 50 00 00 00       	push   $0x50
 c8b:	e9 40 ff ff ff       	jmp    bd0 <_init+0x24>

00000c90 <getenv@plt>:
 c90:	ff a3 38 00 00 00    	jmp    *0x38(%ebx)
 c96:	68 58 00 00 00       	push   $0x58
 c9b:	e9 30 ff ff ff       	jmp    bd0 <_init+0x24>

00000ca0 <puts@plt>:
 ca0:	ff a3 3c 00 00 00    	jmp    *0x3c(%ebx)
 ca6:	68 60 00 00 00       	push   $0x60
 cab:	e9 20 ff ff ff       	jmp    bd0 <_init+0x24>

00000cb0 <strerror@plt>:
 cb0:	ff a3 40 00 00 00    	jmp    *0x40(%ebx)
 cb6:	68 68 00 00 00       	push   $0x68
 cbb:	e9 10 ff ff ff       	jmp    bd0 <_init+0x24>

00000cc0 <__gmon_start__@plt>:
 cc0:	ff a3 44 00 00 00    	jmp    *0x44(%ebx)
 cc6:	68 70 00 00 00       	push   $0x70
 ccb:	e9 00 ff ff ff       	jmp    bd0 <_init+0x24>

00000cd0 <exit@plt>:
 cd0:	ff a3 48 00 00 00    	jmp    *0x48(%ebx)
 cd6:	68 78 00 00 00       	push   $0x78
 cdb:	e9 f0 fe ff ff       	jmp    bd0 <_init+0x24>

00000ce0 <mmap@plt>:
 ce0:	ff a3 4c 00 00 00    	jmp    *0x4c(%ebx)
 ce6:	68 80 00 00 00       	push   $0x80
 ceb:	e9 e0 fe ff ff       	jmp    bd0 <_init+0x24>

00000cf0 <__libc_start_main@plt>:
 cf0:	ff a3 50 00 00 00    	jmp    *0x50(%ebx)
 cf6:	68 88 00 00 00       	push   $0x88
 cfb:	e9 d0 fe ff ff       	jmp    bd0 <_init+0x24>

00000d00 <memset@plt>:
 d00:	ff a3 54 00 00 00    	jmp    *0x54(%ebx)
 d06:	68 90 00 00 00       	push   $0x90
 d0b:	e9 c0 fe ff ff       	jmp    bd0 <_init+0x24>

00000d10 <__errno_location@plt>:
 d10:	ff a3 58 00 00 00    	jmp    *0x58(%ebx)
 d16:	68 98 00 00 00       	push   $0x98
 d1b:	e9 b0 fe ff ff       	jmp    bd0 <_init+0x24>

00000d20 <__vsnprintf_chk@plt>:
 d20:	ff a3 5c 00 00 00    	jmp    *0x5c(%ebx)
 d26:	68 a0 00 00 00       	push   $0xa0
 d2b:	e9 a0 fe ff ff       	jmp    bd0 <_init+0x24>

00000d30 <__printf_chk@plt>:
 d30:	ff a3 60 00 00 00    	jmp    *0x60(%ebx)
 d36:	68 a8 00 00 00       	push   $0xa8
 d3b:	e9 90 fe ff ff       	jmp    bd0 <_init+0x24>

00000d40 <munmap@plt>:
 d40:	ff a3 64 00 00 00    	jmp    *0x64(%ebx)
 d46:	68 b0 00 00 00       	push   $0xb0
 d4b:	e9 80 fe ff ff       	jmp    bd0 <_init+0x24>

00000d50 <abort@plt>:
 d50:	ff a3 68 00 00 00    	jmp    *0x68(%ebx)
 d56:	68 b8 00 00 00       	push   $0xb8
 d5b:	e9 70 fe ff ff       	jmp    bd0 <_init+0x24>

00000d60 <fputs@plt>:
 d60:	ff a3 6c 00 00 00    	jmp    *0x6c(%ebx)
 d66:	68 c0 00 00 00       	push   $0xc0
 d6b:	e9 60 fe ff ff       	jmp    bd0 <_init+0x24>

Disassembly of section .text:

00000d70 <_start>:
     d70:	31 ed                	xor    %ebp,%ebp
     d72:	5e                   	pop    %esi
     d73:	89 e1                	mov    %esp,%ecx
     d75:	83 e4 f0             	and    $0xfffffff0,%esp
     d78:	50                   	push   %eax
     d79:	54                   	push   %esp
     d7a:	52                   	push   %edx
     d7b:	e8 22 00 00 00       	call   da2 <_start+0x32>
     d80:	81 c3 d0 31 00 00    	add    $0x31d0,%ebx
     d86:	8d 83 50 da ff ff    	lea    -0x25b0(%ebx),%eax
     d8c:	50                   	push   %eax
     d8d:	8d 83 e0 d9 ff ff    	lea    -0x2620(%ebx),%eax
     d93:	50                   	push   %eax
     d94:	51                   	push   %ecx
     d95:	56                   	push   %esi
     d96:	ff b3 84 00 00 00    	pushl  0x84(%ebx)
     d9c:	e8 4f ff ff ff       	call   cf0 <__libc_start_main@plt>
     da1:	f4                   	hlt    
     da2:	8b 1c 24             	mov    (%esp),%ebx
     da5:	c3                   	ret    
     da6:	66 90                	xchg   %ax,%ax
     da8:	66 90                	xchg   %ax,%ax
     daa:	66 90                	xchg   %ax,%ax
     dac:	66 90                	xchg   %ax,%ax
     dae:	66 90                	xchg   %ax,%ax

00000db0 <__x86.get_pc_thunk.bx>:
     db0:	8b 1c 24             	mov    (%esp),%ebx
     db3:	c3                   	ret    
     db4:	66 90                	xchg   %ax,%ax
     db6:	66 90                	xchg   %ax,%ax
     db8:	66 90                	xchg   %ax,%ax
     dba:	66 90                	xchg   %ax,%ax
     dbc:	66 90                	xchg   %ax,%ax
     dbe:	66 90                	xchg   %ax,%ax
     dc0:	55                   	push   %ebp
     dc1:	89 e5                	mov    %esp,%ebp
     dc3:	53                   	push   %ebx
     dc4:	e8 e7 ff ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     dc9:	81 c3 87 31 00 00    	add    $0x3187,%ebx
     dcf:	83 ec 04             	sub    $0x4,%esp
     dd2:	8d 93 04 01 00 00    	lea    0x104(%ebx),%edx
     dd8:	8d 83 07 01 00 00    	lea    0x107(%ebx),%eax
     dde:	29 d0                	sub    %edx,%eax
     de0:	83 f8 06             	cmp    $0x6,%eax
     de3:	76 13                	jbe    df8 <__x86.get_pc_thunk.bx+0x48>
     de5:	8b 83 70 00 00 00    	mov    0x70(%ebx),%eax
     deb:	85 c0                	test   %eax,%eax
     ded:	74 09                	je     df8 <__x86.get_pc_thunk.bx+0x48>
     def:	83 ec 0c             	sub    $0xc,%esp
     df2:	52                   	push   %edx
     df3:	ff d0                	call   *%eax
     df5:	83 c4 10             	add    $0x10,%esp
     df8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     dfb:	c9                   	leave  
     dfc:	c3                   	ret    
     dfd:	8d 76 00             	lea    0x0(%esi),%esi
     e00:	55                   	push   %ebp
     e01:	89 e5                	mov    %esp,%ebp
     e03:	53                   	push   %ebx
     e04:	e8 a7 ff ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     e09:	81 c3 47 31 00 00    	add    $0x3147,%ebx
     e0f:	83 ec 04             	sub    $0x4,%esp
     e12:	8d 93 04 01 00 00    	lea    0x104(%ebx),%edx
     e18:	8d 83 04 01 00 00    	lea    0x104(%ebx),%eax
     e1e:	29 d0                	sub    %edx,%eax
     e20:	c1 f8 02             	sar    $0x2,%eax
     e23:	89 c1                	mov    %eax,%ecx
     e25:	c1 e9 1f             	shr    $0x1f,%ecx
     e28:	01 c8                	add    %ecx,%eax
     e2a:	d1 f8                	sar    %eax
     e2c:	74 14                	je     e42 <__x86.get_pc_thunk.bx+0x92>
     e2e:	8b 8b 8c 00 00 00    	mov    0x8c(%ebx),%ecx
     e34:	85 c9                	test   %ecx,%ecx
     e36:	74 0a                	je     e42 <__x86.get_pc_thunk.bx+0x92>
     e38:	83 ec 08             	sub    $0x8,%esp
     e3b:	50                   	push   %eax
     e3c:	52                   	push   %edx
     e3d:	ff d1                	call   *%ecx
     e3f:	83 c4 10             	add    $0x10,%esp
     e42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     e45:	c9                   	leave  
     e46:	c3                   	ret    
     e47:	89 f6                	mov    %esi,%esi
     e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
     e50:	55                   	push   %ebp
     e51:	89 e5                	mov    %esp,%ebp
     e53:	53                   	push   %ebx
     e54:	e8 57 ff ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     e59:	81 c3 f7 30 00 00    	add    $0x30f7,%ebx
     e5f:	83 ec 04             	sub    $0x4,%esp
     e62:	80 bb 04 01 00 00 00 	cmpb   $0x0,0x104(%ebx)
     e69:	75 27                	jne    e92 <__x86.get_pc_thunk.bx+0xe2>
     e6b:	8b 83 78 00 00 00    	mov    0x78(%ebx),%eax
     e71:	85 c0                	test   %eax,%eax
     e73:	74 11                	je     e86 <__x86.get_pc_thunk.bx+0xd6>
     e75:	83 ec 0c             	sub    $0xc,%esp
     e78:	ff b3 b4 00 00 00    	pushl  0xb4(%ebx)
     e7e:	e8 ed fd ff ff       	call   c70 <__cxa_finalize@plt>
     e83:	83 c4 10             	add    $0x10,%esp
     e86:	e8 35 ff ff ff       	call   dc0 <__x86.get_pc_thunk.bx+0x10>
     e8b:	c6 83 04 01 00 00 01 	movb   $0x1,0x104(%ebx)
     e92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     e95:	c9                   	leave  
     e96:	c3                   	ret    
     e97:	89 f6                	mov    %esi,%esi
     e99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
     ea0:	55                   	push   %ebp
     ea1:	89 e5                	mov    %esp,%ebp
     ea3:	53                   	push   %ebx
     ea4:	e8 07 ff ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     ea9:	81 c3 a7 30 00 00    	add    $0x30a7,%ebx
     eaf:	83 ec 04             	sub    $0x4,%esp
     eb2:	8d 83 ec fc ff ff    	lea    -0x314(%ebx),%eax
     eb8:	8b 10                	mov    (%eax),%edx
     eba:	85 d2                	test   %edx,%edx
     ebc:	75 12                	jne    ed0 <__x86.get_pc_thunk.bx+0x120>
     ebe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     ec1:	c9                   	leave  
     ec2:	e9 39 ff ff ff       	jmp    e00 <__x86.get_pc_thunk.bx+0x50>
     ec7:	89 f6                	mov    %esi,%esi
     ec9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
     ed0:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
     ed6:	85 d2                	test   %edx,%edx
     ed8:	74 e4                	je     ebe <__x86.get_pc_thunk.bx+0x10e>
     eda:	83 ec 0c             	sub    $0xc,%esp
     edd:	50                   	push   %eax
     ede:	ff d2                	call   *%edx
     ee0:	83 c4 10             	add    $0x10,%esp
     ee3:	eb d9                	jmp    ebe <__x86.get_pc_thunk.bx+0x10e>

00000ee5 <terminate>:
#ifdef __GNUC__                 /* Prevent 'gcc -Wall' complaining  */
__attribute__ ((__noreturn__))  /* if we call this function as last */
#endif                          /* statement in a non-void function */
static void
terminate(Boolean useExit3)
{
     ee5:	55                   	push   %ebp
     ee6:	89 e5                	mov    %esp,%ebp
     ee8:	56                   	push   %esi
     ee9:	53                   	push   %ebx
     eea:	8d a4 24 e0 ef ff ff 	lea    -0x1020(%esp),%esp
     ef1:	83 0c 24 00          	orl    $0x0,(%esp)
     ef5:	8d a4 24 04 10 00 00 	lea    0x1004(%esp),%esp
     efc:	e8 af fe ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     f01:	81 c3 4f 30 00 00    	add    $0x304f,%ebx
     f07:	89 c6                	mov    %eax,%esi
     f09:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
     f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f12:	31 c0                	xor    %eax,%eax

    /* Dump core if EF_DUMPCORE environment variable is defined and
       is a nonempty string; otherwise call exit(3) or _exit(2),
       depending on the value of 'useExit3'. */

    s = getenv("EF_DUMPCORE");
     f14:	8d 83 a0 da ff ff    	lea    -0x2560(%ebx),%eax
     f1a:	50                   	push   %eax
     f1b:	e8 70 fd ff ff       	call   c90 <getenv@plt>

    if (s != NULL && *s != '\0')
     f20:	83 c4 10             	add    $0x10,%esp
     f23:	85 c0                	test   %eax,%eax
     f25:	74 0a                	je     f31 <terminate+0x4c>
     f27:	80 38 00             	cmpb   $0x0,(%eax)
     f2a:	74 05                	je     f31 <terminate+0x4c>
        abort();
     f2c:	e8 1f fe ff ff       	call   d50 <abort@plt>
    else if (useExit3)
     f31:	89 f0                	mov    %esi,%eax
     f33:	84 c0                	test   %al,%al
     f35:	74 0a                	je     f41 <terminate+0x5c>
        exit(EXIT_FAILURE);
     f37:	83 ec 0c             	sub    $0xc,%esp
     f3a:	6a 01                	push   $0x1
     f3c:	e8 8f fd ff ff       	call   cd0 <exit@plt>
    else
        _exit(EXIT_FAILURE);
     f41:	83 ec 0c             	sub    $0xc,%esp
     f44:	6a 01                	push   $0x1
     f46:	e8 d5 fc ff ff       	call   c20 <_exit@plt>

00000f4b <outputError>:
        'format' and 'ap'. */

static void
outputError(Boolean useErr, int err, Boolean flushStdout,
        const char *format, va_list ap)
{
     f4b:	55                   	push   %ebp
     f4c:	89 e5                	mov    %esp,%ebp
     f4e:	57                   	push   %edi
     f4f:	56                   	push   %esi
     f50:	53                   	push   %ebx
     f51:	8d a4 24 f4 e9 ff ff 	lea    -0x160c(%esp),%esp
     f58:	83 0c 24 00          	orl    $0x0,(%esp)
     f5c:	8d a4 24 08 10 00 00 	lea    0x1008(%esp),%esp
     f63:	e8 48 fe ff ff       	call   db0 <__x86.get_pc_thunk.bx>
     f68:	81 c3 e8 2f 00 00    	add    $0x2fe8,%ebx
     f6e:	89 85 04 fa ff ff    	mov    %eax,-0x5fc(%ebp)
     f74:	89 d6                	mov    %edx,%esi
     f76:	8b 7d 08             	mov    0x8(%ebp),%edi
     f79:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
     f80:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
     f83:	31 c9                	xor    %ecx,%ecx

__fortify_function int
__NTH (vsnprintf (char *__restrict __s, size_t __n,
		  const char *__restrict __fmt, _G_va_list __ap))
{
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
     f85:	ff 75 10             	pushl  0x10(%ebp)
     f88:	ff 75 0c             	pushl  0xc(%ebp)
     f8b:	68 f4 01 00 00       	push   $0x1f4
     f90:	6a 01                	push   $0x1
     f92:	68 f4 01 00 00       	push   $0x1f4
     f97:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
     f9d:	50                   	push   %eax
     f9e:	e8 7d fd ff ff       	call   d20 <__vsnprintf_chk@plt>
#define BUF_SIZE 500
    char buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];

    vsnprintf(userMsg, BUF_SIZE, format, ap);

    if (useErr)
     fa3:	83 c4 20             	add    $0x20,%esp
     fa6:	80 bd 04 fa ff ff 00 	cmpb   $0x0,-0x5fc(%ebp)
     fad:	74 4f                	je     ffe <outputError+0xb3>
        snprintf(errText, BUF_SIZE, " [%s %s]",
     faf:	83 ec 0c             	sub    $0xc,%esp
     fb2:	56                   	push   %esi
     fb3:	e8 f8 fc ff ff       	call   cb0 <strerror@plt>
                (err > 0 && err <= MAX_ENAME) ?
     fb8:	8d 56 ff             	lea    -0x1(%esi),%edx
    char buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];

    vsnprintf(userMsg, BUF_SIZE, format, ap);

    if (useErr)
        snprintf(errText, BUF_SIZE, " [%s %s]",
     fbb:	83 c4 10             	add    $0x10,%esp
     fbe:	81 fa 84 00 00 00    	cmp    $0x84,%edx
     fc4:	77 09                	ja     fcf <outputError+0x84>
     fc6:	8b 94 b3 f0 fc ff ff 	mov    -0x310(%ebx,%esi,4),%edx
     fcd:	eb 06                	jmp    fd5 <outputError+0x8a>
     fcf:	8d 93 ac da ff ff    	lea    -0x2554(%ebx),%edx
# ifdef __va_arg_pack
__fortify_function int
__NTH (snprintf (char *__restrict __s, size_t __n,
		 const char *__restrict __fmt, ...))
{
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
     fd5:	83 ec 04             	sub    $0x4,%esp
     fd8:	50                   	push   %eax
     fd9:	52                   	push   %edx
     fda:	8d 83 b6 da ff ff    	lea    -0x254a(%ebx),%eax
     fe0:	50                   	push   %eax
     fe1:	68 f4 01 00 00       	push   $0x1f4
     fe6:	6a 01                	push   $0x1
     fe8:	68 f4 01 00 00       	push   $0x1f4
     fed:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
     ff3:	50                   	push   %eax
     ff4:	e8 e7 fb ff ff       	call   be0 <__snprintf_chk@plt>
     ff9:	83 c4 20             	add    $0x20,%esp
     ffc:	eb 09                	jmp    1007 <outputError+0xbc>
     ffe:	66 c7 85 f0 fd ff ff 	movw   $0x3a,-0x210(%ebp)
    1005:	3a 00 
    1007:	83 ec 04             	sub    $0x4,%esp
    100a:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
    1010:	50                   	push   %eax
    1011:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
    1017:	50                   	push   %eax
    1018:	8d 83 bf da ff ff    	lea    -0x2541(%ebx),%eax
    101e:	50                   	push   %eax
    101f:	68 f4 01 00 00       	push   $0x1f4
    1024:	6a 01                	push   $0x1
    1026:	68 f4 01 00 00       	push   $0x1f4
    102b:	8d 85 08 fa ff ff    	lea    -0x5f8(%ebp),%eax
    1031:	50                   	push   %eax
    1032:	e8 a9 fb ff ff       	call   be0 <__snprintf_chk@plt>
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-truncation"
    snprintf(buf, BUF_SIZE, "ERROR%s %s\n", errText, userMsg);
#pragma GCC diagnostic pop

    if (flushStdout)
    1037:	83 c4 20             	add    $0x20,%esp
    103a:	89 f8                	mov    %edi,%eax
    103c:	84 c0                	test   %al,%al
    103e:	74 13                	je     1053 <outputError+0x108>
        fflush(stdout);       /* Flush any pending stdout */
    1040:	83 ec 0c             	sub    $0xc,%esp
    1043:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
    1049:	ff 30                	pushl  (%eax)
    104b:	e8 c0 fb ff ff       	call   c10 <fflush@plt>
    1050:	83 c4 10             	add    $0x10,%esp
    fputs(buf, stderr);
    1053:	83 ec 08             	sub    $0x8,%esp
    1056:	8b b3 74 00 00 00    	mov    0x74(%ebx),%esi
    105c:	ff 36                	pushl  (%esi)
    105e:	8d 85 08 fa ff ff    	lea    -0x5f8(%ebp),%eax
    1064:	50                   	push   %eax
    1065:	e8 f6 fc ff ff       	call   d60 <fputs@plt>
    fflush(stderr);           /* In case stderr is not line-buffered */
    106a:	83 c4 04             	add    $0x4,%esp
    106d:	ff 36                	pushl  (%esi)
    106f:	e8 9c fb ff ff       	call   c10 <fflush@plt>
    1074:	83 c4 10             	add    $0x10,%esp
}
    1077:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    107a:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    1081:	74 05                	je     1088 <outputError+0x13d>
    1083:	e8 28 09 00 00       	call   19b0 <__stack_chk_fail_local>
    1088:	8d 65 f4             	lea    -0xc(%ebp),%esp
    108b:	5b                   	pop    %ebx
    108c:	5e                   	pop    %esi
    108d:	5f                   	pop    %edi
    108e:	5d                   	pop    %ebp
    108f:	c3                   	ret    

00001090 <errMsg>:
/* Display error message including 'errno' diagnostic, and
   return to caller */

void
errMsg(const char *format, ...)
{
    1090:	55                   	push   %ebp
    1091:	89 e5                	mov    %esp,%ebp
    1093:	57                   	push   %edi
    1094:	56                   	push   %esi
    1095:	53                   	push   %ebx
    1096:	8d a4 24 c4 ef ff ff 	lea    -0x103c(%esp),%esp
    109d:	83 0c 24 00          	orl    $0x0,(%esp)
    10a1:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    10a8:	e8 03 fd ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    10ad:	81 c3 a3 2e 00 00    	add    $0x2ea3,%ebx
    10b3:	8b 7d 08             	mov    0x8(%ebp),%edi
    10b6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    10bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    10bf:	31 c0                	xor    %eax,%eax
    va_list argList;
    int savedErrno;

    savedErrno = errno;       /* In case we change it here */
    10c1:	e8 4a fc ff ff       	call   d10 <__errno_location@plt>
    10c6:	89 c6                	mov    %eax,%esi
    10c8:	8b 00                	mov    (%eax),%eax
    10ca:	89 45 d4             	mov    %eax,-0x2c(%ebp)

    va_start(argList, format);
    10cd:	8d 45 0c             	lea    0xc(%ebp),%eax
    outputError(TRUE, errno, TRUE, format, argList);
    10d0:	83 ec 04             	sub    $0x4,%esp
    10d3:	50                   	push   %eax
    10d4:	57                   	push   %edi
    10d5:	6a 01                	push   $0x1
    10d7:	8b 16                	mov    (%esi),%edx
    10d9:	b8 01 00 00 00       	mov    $0x1,%eax
    10de:	e8 68 fe ff ff       	call   f4b <outputError>
    va_end(argList);

    errno = savedErrno;
    10e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    10e6:	89 06                	mov    %eax,(%esi)
    10e8:	83 c4 10             	add    $0x10,%esp
}
    10eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    10ee:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    10f5:	74 05                	je     10fc <errMsg+0x6c>
    10f7:	e8 b4 08 00 00       	call   19b0 <__stack_chk_fail_local>
    10fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    10ff:	5b                   	pop    %ebx
    1100:	5e                   	pop    %esi
    1101:	5f                   	pop    %edi
    1102:	5d                   	pop    %ebp
    1103:	c3                   	ret    

00001104 <errExit>:
/* Display error message including 'errno' diagnostic, and
   terminate the process */

void
errExit(const char *format, ...)
{
    1104:	55                   	push   %ebp
    1105:	89 e5                	mov    %esp,%ebp
    1107:	57                   	push   %edi
    1108:	56                   	push   %esi
    1109:	53                   	push   %ebx
    110a:	8d a4 24 d4 ef ff ff 	lea    -0x102c(%esp),%esp
    1111:	83 0c 24 00          	orl    $0x0,(%esp)
    1115:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    111c:	e8 8f fc ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    1121:	81 c3 2f 2e 00 00    	add    $0x2e2f,%ebx
    1127:	8b 75 08             	mov    0x8(%ebp),%esi
    112a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    1130:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1133:	31 c0                	xor    %eax,%eax
    va_list argList;

    va_start(argList, format);
    1135:	8d 7d 0c             	lea    0xc(%ebp),%edi
    outputError(TRUE, errno, TRUE, format, argList);
    1138:	e8 d3 fb ff ff       	call   d10 <__errno_location@plt>
    113d:	83 ec 04             	sub    $0x4,%esp
    1140:	57                   	push   %edi
    1141:	56                   	push   %esi
    1142:	6a 01                	push   $0x1
    1144:	8b 10                	mov    (%eax),%edx
    1146:	b8 01 00 00 00       	mov    $0x1,%eax
    114b:	e8 fb fd ff ff       	call   f4b <outputError>
    va_end(argList);

    terminate(TRUE);
    1150:	b8 01 00 00 00       	mov    $0x1,%eax
    1155:	e8 8b fd ff ff       	call   ee5 <terminate>

0000115a <err_exit>:
   stdio buffers that were partially filled by the caller and without
   invoking exit handlers that were established by the caller. */

void
err_exit(const char *format, ...)
{
    115a:	55                   	push   %ebp
    115b:	89 e5                	mov    %esp,%ebp
    115d:	57                   	push   %edi
    115e:	56                   	push   %esi
    115f:	53                   	push   %ebx
    1160:	8d a4 24 d4 ef ff ff 	lea    -0x102c(%esp),%esp
    1167:	83 0c 24 00          	orl    $0x0,(%esp)
    116b:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    1172:	e8 39 fc ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    1177:	81 c3 d9 2d 00 00    	add    $0x2dd9,%ebx
    117d:	8b 75 08             	mov    0x8(%ebp),%esi
    1180:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    1186:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1189:	31 c0                	xor    %eax,%eax
    va_list argList;

    va_start(argList, format);
    118b:	8d 7d 0c             	lea    0xc(%ebp),%edi
    outputError(TRUE, errno, FALSE, format, argList);
    118e:	e8 7d fb ff ff       	call   d10 <__errno_location@plt>
    1193:	83 ec 04             	sub    $0x4,%esp
    1196:	57                   	push   %edi
    1197:	56                   	push   %esi
    1198:	6a 00                	push   $0x0
    119a:	8b 10                	mov    (%eax),%edx
    119c:	b8 01 00 00 00       	mov    $0x1,%eax
    11a1:	e8 a5 fd ff ff       	call   f4b <outputError>
    va_end(argList);

    terminate(FALSE);
    11a6:	b8 00 00 00 00       	mov    $0x0,%eax
    11ab:	e8 35 fd ff ff       	call   ee5 <terminate>

000011b0 <errExitEN>:
/* The following function does the same as errExit(), but expects
   the error number in 'errnum' */

void
errExitEN(int errnum, const char *format, ...)
{
    11b0:	55                   	push   %ebp
    11b1:	89 e5                	mov    %esp,%ebp
    11b3:	8d a4 24 d8 ef ff ff 	lea    -0x1028(%esp),%esp
    11ba:	83 0c 24 00          	orl    $0x0,(%esp)
    11be:	8d a4 24 0c 10 00 00 	lea    0x100c(%esp),%esp
    11c5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    11cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    11ce:	31 c0                	xor    %eax,%eax
    va_list argList;

    va_start(argList, format);
    11d0:	8d 45 10             	lea    0x10(%ebp),%eax
    outputError(TRUE, errnum, TRUE, format, argList);
    11d3:	50                   	push   %eax
    11d4:	ff 75 0c             	pushl  0xc(%ebp)
    11d7:	6a 01                	push   $0x1
    11d9:	8b 55 08             	mov    0x8(%ebp),%edx
    11dc:	b8 01 00 00 00       	mov    $0x1,%eax
    11e1:	e8 65 fd ff ff       	call   f4b <outputError>
    va_end(argList);

    terminate(TRUE);
    11e6:	b8 01 00 00 00       	mov    $0x1,%eax
    11eb:	e8 f5 fc ff ff       	call   ee5 <terminate>

000011f0 <fatal>:

/* Print an error message (without an 'errno' diagnostic) */

void
fatal(const char *format, ...)
{
    11f0:	55                   	push   %ebp
    11f1:	89 e5                	mov    %esp,%ebp
    11f3:	8d a4 24 d8 ef ff ff 	lea    -0x1028(%esp),%esp
    11fa:	83 0c 24 00          	orl    $0x0,(%esp)
    11fe:	8d a4 24 0c 10 00 00 	lea    0x100c(%esp),%esp
    1205:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    120b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    120e:	31 c0                	xor    %eax,%eax
    va_list argList;

    va_start(argList, format);
    1210:	8d 45 0c             	lea    0xc(%ebp),%eax
    outputError(FALSE, 0, TRUE, format, argList);
    1213:	50                   	push   %eax
    1214:	ff 75 08             	pushl  0x8(%ebp)
    1217:	6a 01                	push   $0x1
    1219:	ba 00 00 00 00       	mov    $0x0,%edx
    121e:	b8 00 00 00 00       	mov    $0x0,%eax
    1223:	e8 23 fd ff ff       	call   f4b <outputError>
    va_end(argList);

    terminate(TRUE);
    1228:	b8 01 00 00 00       	mov    $0x1,%eax
    122d:	e8 b3 fc ff ff       	call   ee5 <terminate>

00001232 <usageErr>:

/* Print a command usage error message and terminate the process */

void
usageErr(const char *format, ...)
{
    1232:	55                   	push   %ebp
    1233:	89 e5                	mov    %esp,%ebp
    1235:	57                   	push   %edi
    1236:	56                   	push   %esi
    1237:	53                   	push   %ebx
    1238:	8d a4 24 d4 ef ff ff 	lea    -0x102c(%esp),%esp
    123f:	83 0c 24 00          	orl    $0x0,(%esp)
    1243:	8d a4 24 04 10 00 00 	lea    0x1004(%esp),%esp
    124a:	e8 61 fb ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    124f:	81 c3 01 2d 00 00    	add    $0x2d01,%ebx
    1255:	8b 7d 08             	mov    0x8(%ebp),%edi
    1258:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    125e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1261:	31 c0                	xor    %eax,%eax
    va_list argList;

    fflush(stdout);           /* Flush any pending stdout */
    1263:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
    1269:	ff 30                	pushl  (%eax)
    126b:	e8 a0 f9 ff ff       	call   c10 <fflush@plt>

    fprintf(stderr, "Usage: ");
    1270:	8b b3 74 00 00 00    	mov    0x74(%ebx),%esi

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    1276:	ff 36                	pushl  (%esi)
    1278:	6a 07                	push   $0x7
    127a:	6a 01                	push   $0x1
    127c:	8d 83 cb da ff ff    	lea    -0x2535(%ebx),%eax
    1282:	50                   	push   %eax
    1283:	e8 f8 f9 ff ff       	call   c80 <fwrite@plt>
    va_start(argList, format);
    1288:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, _G_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    128b:	83 c4 20             	add    $0x20,%esp
    128e:	50                   	push   %eax
    128f:	57                   	push   %edi
    1290:	6a 01                	push   $0x1
    1292:	ff 36                	pushl  (%esi)
    1294:	e8 57 f9 ff ff       	call   bf0 <__vfprintf_chk@plt>
    vfprintf(stderr, format, argList);
    va_end(argList);

    fflush(stderr);           /* In case stderr is not line-buffered */
    1299:	83 c4 04             	add    $0x4,%esp
    129c:	ff 36                	pushl  (%esi)
    129e:	e8 6d f9 ff ff       	call   c10 <fflush@plt>
    exit(EXIT_FAILURE);
    12a3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    12aa:	e8 21 fa ff ff       	call   cd0 <exit@plt>

000012af <cmdLineErr>:
/* Diagnose an error in command-line arguments and
   terminate the process */

void
cmdLineErr(const char *format, ...)
{
    12af:	55                   	push   %ebp
    12b0:	89 e5                	mov    %esp,%ebp
    12b2:	57                   	push   %edi
    12b3:	56                   	push   %esi
    12b4:	53                   	push   %ebx
    12b5:	8d a4 24 d4 ef ff ff 	lea    -0x102c(%esp),%esp
    12bc:	83 0c 24 00          	orl    $0x0,(%esp)
    12c0:	8d a4 24 04 10 00 00 	lea    0x1004(%esp),%esp
    12c7:	e8 e4 fa ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    12cc:	81 c3 84 2c 00 00    	add    $0x2c84,%ebx
    12d2:	8b 7d 08             	mov    0x8(%ebp),%edi
    12d5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    12db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    12de:	31 c0                	xor    %eax,%eax
    va_list argList;

    fflush(stdout);           /* Flush any pending stdout */
    12e0:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
    12e6:	ff 30                	pushl  (%eax)
    12e8:	e8 23 f9 ff ff       	call   c10 <fflush@plt>

    fprintf(stderr, "Command-line usage error: ");
    12ed:	8b b3 74 00 00 00    	mov    0x74(%ebx),%esi

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    12f3:	ff 36                	pushl  (%esi)
    12f5:	6a 1a                	push   $0x1a
    12f7:	6a 01                	push   $0x1
    12f9:	8d 83 d3 da ff ff    	lea    -0x252d(%ebx),%eax
    12ff:	50                   	push   %eax
    1300:	e8 7b f9 ff ff       	call   c80 <fwrite@plt>
    va_start(argList, format);
    1305:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, _G_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    1308:	83 c4 20             	add    $0x20,%esp
    130b:	50                   	push   %eax
    130c:	57                   	push   %edi
    130d:	6a 01                	push   $0x1
    130f:	ff 36                	pushl  (%esi)
    1311:	e8 da f8 ff ff       	call   bf0 <__vfprintf_chk@plt>
    vfprintf(stderr, format, argList);
    va_end(argList);

    fflush(stderr);           /* In case stderr is not line-buffered */
    1316:	83 c4 04             	add    $0x4,%esp
    1319:	ff 36                	pushl  (%esi)
    131b:	e8 f0 f8 ff ff       	call   c10 <fflush@plt>
    exit(EXIT_FAILURE);
    1320:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1327:	e8 a4 f9 ff ff       	call   cd0 <exit@plt>

0000132c <f_int>:

#define OPCODE_LEN 52
uint8_t f_opcode[OPCODE_LEN] = {0x48, 0x83, 0xec, 0x18, 0x64, 0x48, 0x8b, 0x04, 0x25, 0x28, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x08, 0x31, 0xc0, 0x90, 0x48, 0x8b, 0x54, 0x24, 0x08, 0x64, 0x48, 0x33, 0x14, 0x25, 0x28, 0x00, 0x00, 0x00, 0x75, 0x0a, 0xb8, 0xee, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x18, 0xc3, 0xe8, 0xa0, 0xf6, 0xff, 0xff};

uint8_t f_int(void)
{
    132c:	55                   	push   %ebp
    132d:	89 e5                	mov    %esp,%ebp
    132f:	8d a4 24 d8 ef ff ff 	lea    -0x1028(%esp),%esp
    1336:	83 0c 24 00          	orl    $0x0,(%esp)
    133a:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    1341:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    1347:	89 45 f4             	mov    %eax,-0xc(%ebp)
    134a:	31 c0                	xor    %eax,%eax
    __asm("nop");
    134c:	90                   	nop
    return 0xee;
}
    134d:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
    1352:	8b 55 f4             	mov    -0xc(%ebp),%edx
    1355:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
    135c:	74 05                	je     1363 <f_int+0x37>
    135e:	e8 4d 06 00 00       	call   19b0 <__stack_chk_fail_local>
    1363:	c9                   	leave  
    1364:	c3                   	ret    

00001365 <exec_opcode>:

// function that executes an array of opcodes
// based on https://stackoverflow.com/questions/37122186/c-put-x86-instructions-into-array-and-execute-them
uint8_t exec_opcode(const uint8_t *code, size_t codelen)
{
    1365:	55                   	push   %ebp
    1366:	89 e5                	mov    %esp,%ebp
    1368:	57                   	push   %edi
    1369:	56                   	push   %esi
    136a:	53                   	push   %ebx
    136b:	8d a4 24 c4 ef ff ff 	lea    -0x103c(%esp),%esp
    1372:	83 0c 24 00          	orl    $0x0,(%esp)
    1376:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    137d:	e8 2e fa ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    1382:	81 c3 ce 2b 00 00    	add    $0x2bce,%ebx
    1388:	8b 45 08             	mov    0x8(%ebp),%eax
    138b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    138e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1391:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1394:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    139a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    139d:	31 c0                	xor    %eax,%eax
    uint8_t ret;
    // in order to manipulate memory protection, we must work with
    // whole pages allocated directly from the operating system.
    static size_t pagesize;
    if (!pagesize) {
    139f:	83 bb 0c 01 00 00 00 	cmpl   $0x0,0x10c(%ebx)
    13a6:	75 27                	jne    13cf <exec_opcode+0x6a>
        pagesize = sysconf(_SC_PAGESIZE);
    13a8:	83 ec 0c             	sub    $0xc,%esp
    13ab:	6a 1e                	push   $0x1e
    13ad:	e8 ae f8 ff ff       	call   c60 <sysconf@plt>
    13b2:	89 83 0c 01 00 00    	mov    %eax,0x10c(%ebx)
        if (pagesize == (size_t)-1) {
    13b8:	83 c4 10             	add    $0x10,%esp
    13bb:	83 f8 ff             	cmp    $0xffffffff,%eax
    13be:	75 0f                	jne    13cf <exec_opcode+0x6a>
            errExit("getpagesize");
    13c0:	83 ec 0c             	sub    $0xc,%esp
    13c3:	8d 83 5b df ff ff    	lea    -0x20a5(%ebx),%eax
    13c9:	50                   	push   %eax
    13ca:	e8 35 fd ff ff       	call   1104 <errExit>
    }

    // allocate at least enough space for the code + 1 byte
    // (so that there will be at least one INT3 - see below),
    // rounded up to a multiple of the system page size.
    size_t rounded_codesize = ((codelen + 1 + pagesize - 1)
    13cf:	8b 8b 0c 01 00 00    	mov    0x10c(%ebx),%ecx
    13d5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    13d8:	01 c8                	add    %ecx,%eax
                               / pagesize) * pagesize;
    13da:	ba 00 00 00 00       	mov    $0x0,%edx
    13df:	f7 f1                	div    %ecx
    }

    // allocate at least enough space for the code + 1 byte
    // (so that there will be at least one INT3 - see below),
    // rounded up to a multiple of the system page size.
    size_t rounded_codesize = ((codelen + 1 + pagesize - 1)
    13e1:	0f af c8             	imul   %eax,%ecx
    13e4:	89 cf                	mov    %ecx,%edi
                               / pagesize) * pagesize;

    void *executable_area = mmap(0, rounded_codesize,
    13e6:	83 ec 08             	sub    $0x8,%esp
    13e9:	6a 00                	push   $0x0
    13eb:	6a ff                	push   $0xffffffff
    13ed:	6a 22                	push   $0x22
    13ef:	6a 03                	push   $0x3
    13f1:	51                   	push   %ecx
    13f2:	6a 00                	push   $0x0
    13f4:	e8 e7 f8 ff ff       	call   ce0 <mmap@plt>
    13f9:	89 c6                	mov    %eax,%esi
                                 PROT_READ|PROT_WRITE,
                                 MAP_PRIVATE|MAP_ANONYMOUS,
                                 -1, 0);
    if (!executable_area) {
    13fb:	83 c4 20             	add    $0x20,%esp
    13fe:	85 c0                	test   %eax,%eax
    1400:	75 0f                	jne    1411 <exec_opcode+0xac>
        errExit("mmap");
    1402:	83 ec 0c             	sub    $0xc,%esp
    1405:	8d 83 67 df ff ff    	lea    -0x2099(%ebx),%eax
    140b:	50                   	push   %eax
    140c:	e8 f3 fc ff ff       	call   1104 <errExit>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    1411:	83 ec 04             	sub    $0x4,%esp
    1414:	ff 75 d4             	pushl  -0x2c(%ebp)
    1417:	ff 75 d0             	pushl  -0x30(%ebp)
    141a:	50                   	push   %eax
    141b:	e8 10 f8 ff ff       	call   c30 <memcpy@plt>
    memcpy(executable_area, code, codelen);

    // fill the space at the end with INT3 instructions, to guarantee
    // a prompt crash if the generated code runs off the end.
    // must change this if generating code for non-x86.
    memset(executable_area + codelen, 0xCC, rounded_codesize - codelen);
    1420:	89 fa                	mov    %edi,%edx
    1422:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1425:	29 c2                	sub    %eax,%edx
    1427:	01 f0                	add    %esi,%eax
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    1429:	83 c4 0c             	add    $0xc,%esp
    142c:	52                   	push   %edx
    142d:	68 cc 00 00 00       	push   $0xcc
    1432:	50                   	push   %eax
    1433:	e8 c8 f8 ff ff       	call   d00 <memset@plt>

    // make executable_area actually executable (and unwritable)
    if (mprotect(executable_area, rounded_codesize, PROT_READ|PROT_EXEC)) {
    1438:	83 c4 0c             	add    $0xc,%esp
    143b:	6a 05                	push   $0x5
    143d:	57                   	push   %edi
    143e:	56                   	push   %esi
    143f:	e8 bc f7 ff ff       	call   c00 <mprotect@plt>
    1444:	83 c4 10             	add    $0x10,%esp
    1447:	85 c0                	test   %eax,%eax
    1449:	74 0f                	je     145a <exec_opcode+0xf5>
        errExit("mprotect");
    144b:	83 ec 0c             	sub    $0xc,%esp
    144e:	8d 83 6c df ff ff    	lea    -0x2094(%ebx),%eax
    1454:	50                   	push   %eax
    1455:	e8 aa fc ff ff       	call   1104 <errExit>
    }

    // now we can call it
    ret = ((uint8_t (*)(void)) executable_area)();
    145a:	ff d6                	call   *%esi
    145c:	88 45 d4             	mov    %al,-0x2c(%ebp)

    munmap(executable_area, rounded_codesize);
    145f:	83 ec 08             	sub    $0x8,%esp
    1462:	57                   	push   %edi
    1463:	56                   	push   %esi
    1464:	e8 d7 f8 ff ff       	call   d40 <munmap@plt>
    return ret;
    1469:	83 c4 10             	add    $0x10,%esp
}
    146c:	0f b6 45 d4          	movzbl -0x2c(%ebp),%eax
    1470:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    1473:	65 33 3d 14 00 00 00 	xor    %gs:0x14,%edi
    147a:	74 05                	je     1481 <exec_opcode+0x11c>
    147c:	e8 2f 05 00 00       	call   19b0 <__stack_chk_fail_local>
    1481:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1484:	5b                   	pop    %ebx
    1485:	5e                   	pop    %esi
    1486:	5f                   	pop    %edi
    1487:	5d                   	pop    %ebp
    1488:	c3                   	ret    

00001489 <exec_opcode_WX>:


// same as above, but asume writable memory can be executed
uint8_t exec_opcode_WX(const uint8_t *code, size_t codelen)
{
    1489:	55                   	push   %ebp
    148a:	89 e5                	mov    %esp,%ebp
    148c:	57                   	push   %edi
    148d:	56                   	push   %esi
    148e:	53                   	push   %ebx
    148f:	8d a4 24 c4 ef ff ff 	lea    -0x103c(%esp),%esp
    1496:	83 0c 24 00          	orl    $0x0,(%esp)
    149a:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    14a1:	e8 0a f9 ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    14a6:	81 c3 aa 2a 00 00    	add    $0x2aaa,%ebx
    14ac:	8b 45 08             	mov    0x8(%ebp),%eax
    14af:	89 45 d0             	mov    %eax,-0x30(%ebp)
    14b2:	8b 75 0c             	mov    0xc(%ebp),%esi
    14b5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    14bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    14be:	31 c0                	xor    %eax,%eax
    uint8_t ret;
    // in order to manipulate memory protection, we must work with
    // whole pages allocated directly from the operating system.
    static size_t pagesize;
    if (!pagesize) {
    14c0:	83 bb 08 01 00 00 00 	cmpl   $0x0,0x108(%ebx)
    14c7:	75 27                	jne    14f0 <exec_opcode_WX+0x67>
        pagesize = sysconf(_SC_PAGESIZE);
    14c9:	83 ec 0c             	sub    $0xc,%esp
    14cc:	6a 1e                	push   $0x1e
    14ce:	e8 8d f7 ff ff       	call   c60 <sysconf@plt>
    14d3:	89 83 08 01 00 00    	mov    %eax,0x108(%ebx)
        if (pagesize == (size_t)-1) {
    14d9:	83 c4 10             	add    $0x10,%esp
    14dc:	83 f8 ff             	cmp    $0xffffffff,%eax
    14df:	75 0f                	jne    14f0 <exec_opcode_WX+0x67>
            errExit("getpagesize");
    14e1:	83 ec 0c             	sub    $0xc,%esp
    14e4:	8d 83 5b df ff ff    	lea    -0x20a5(%ebx),%eax
    14ea:	50                   	push   %eax
    14eb:	e8 14 fc ff ff       	call   1104 <errExit>
    }

    // allocate at least enough space for the code + 1 byte
    // (so that there will be at least one INT3 - see below),
    // rounded up to a multiple of the system page size.
    size_t rounded_codesize = ((codelen + 1 + pagesize - 1)
    14f0:	8b 8b 08 01 00 00    	mov    0x108(%ebx),%ecx
    14f6:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
                               / pagesize) * pagesize;
    14f9:	ba 00 00 00 00       	mov    $0x0,%edx
    14fe:	f7 f1                	div    %ecx
    }

    // allocate at least enough space for the code + 1 byte
    // (so that there will be at least one INT3 - see below),
    // rounded up to a multiple of the system page size.
    size_t rounded_codesize = ((codelen + 1 + pagesize - 1)
    1500:	0f af c8             	imul   %eax,%ecx
    1503:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
                               / pagesize) * pagesize;

    void *executable_area = mmap(0, rounded_codesize,
    1506:	83 ec 08             	sub    $0x8,%esp
    1509:	6a 00                	push   $0x0
    150b:	6a ff                	push   $0xffffffff
    150d:	6a 22                	push   $0x22
    150f:	6a 07                	push   $0x7
    1511:	51                   	push   %ecx
    1512:	6a 00                	push   $0x0
    1514:	e8 c7 f7 ff ff       	call   ce0 <mmap@plt>
    1519:	89 c7                	mov    %eax,%edi
                                 PROT_READ|PROT_WRITE|PROT_EXEC,
                                 MAP_PRIVATE|MAP_ANONYMOUS,
                                 -1, 0);
    if (!executable_area) {
    151b:	83 c4 20             	add    $0x20,%esp
    151e:	85 c0                	test   %eax,%eax
    1520:	75 0f                	jne    1531 <exec_opcode_WX+0xa8>
        errExit("mmap");
    1522:	83 ec 0c             	sub    $0xc,%esp
    1525:	8d 83 67 df ff ff    	lea    -0x2099(%ebx),%eax
    152b:	50                   	push   %eax
    152c:	e8 d3 fb ff ff       	call   1104 <errExit>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    1531:	83 ec 04             	sub    $0x4,%esp
    1534:	56                   	push   %esi
    1535:	ff 75 d0             	pushl  -0x30(%ebp)
    1538:	50                   	push   %eax
    1539:	e8 f2 f6 ff ff       	call   c30 <memcpy@plt>
    memcpy(executable_area, code, codelen);

    // fill the space at the end with INT3 instructions, to guarantee
    // a prompt crash if the generated code runs off the end.
    // must change this if generating code for non-x86.
    memset(executable_area + codelen, 0xCC, rounded_codesize - codelen);
    153e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1541:	29 f0                	sub    %esi,%eax
    1543:	01 fe                	add    %edi,%esi
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    1545:	83 c4 0c             	add    $0xc,%esp
    1548:	50                   	push   %eax
    1549:	68 cc 00 00 00       	push   $0xcc
    154e:	56                   	push   %esi
    154f:	e8 ac f7 ff ff       	call   d00 <memset@plt>

    // now we can call it
    ret = ((uint8_t (*)(void)) executable_area)();
    1554:	ff d7                	call   *%edi
    1556:	89 c6                	mov    %eax,%esi

    munmap(executable_area, rounded_codesize);
    1558:	83 c4 08             	add    $0x8,%esp
    155b:	ff 75 d4             	pushl  -0x2c(%ebp)
    155e:	57                   	push   %edi
    155f:	e8 dc f7 ff ff       	call   d40 <munmap@plt>
    return ret;
    1564:	83 c4 10             	add    $0x10,%esp
}
    1567:	89 f0                	mov    %esi,%eax
    1569:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    156c:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
    1573:	74 05                	je     157a <exec_opcode_WX+0xf1>
    1575:	e8 36 04 00 00       	call   19b0 <__stack_chk_fail_local>
    157a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    157d:	5b                   	pop    %ebx
    157e:	5e                   	pop    %esi
    157f:	5f                   	pop    %edi
    1580:	5d                   	pop    %ebp
    1581:	c3                   	ret    

00001582 <exec_opcode_no_mmap>:

// same as above, but asume writable memory can be executed and no mmap is needed
uint8_t exec_opcode_no_mmap(const uint8_t *code, size_t codelen)
{
    1582:	55                   	push   %ebp
    1583:	89 e5                	mov    %esp,%ebp
    1585:	8d a4 24 d8 ef ff ff 	lea    -0x1028(%esp),%esp
    158c:	83 0c 24 00          	orl    $0x0,(%esp)
    1590:	8d a4 24 10 10 00 00 	lea    0x1010(%esp),%esp
    1597:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    159d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    15a0:	31 c0                	xor    %eax,%eax
    uint8_t ret;

    // now we can call it
    ret = ((uint8_t (*)(void)) code)();
    15a2:	ff 55 08             	call   *0x8(%ebp)
    return ret;
}
    15a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    15a8:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
    15af:	74 05                	je     15b6 <exec_opcode_no_mmap+0x34>
    15b1:	e8 fa 03 00 00       	call   19b0 <__stack_chk_fail_local>
    15b6:	c9                   	leave  
    15b7:	c3                   	ret    

000015b8 <main>:

int main()
{
    15b8:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    15bc:	83 e4 f0             	and    $0xfffffff0,%esp
    15bf:	ff 71 fc             	pushl  -0x4(%ecx)
    15c2:	55                   	push   %ebp
    15c3:	89 e5                	mov    %esp,%ebp
    15c5:	57                   	push   %edi
    15c6:	56                   	push   %esi
    15c7:	53                   	push   %ebx
    15c8:	51                   	push   %ecx
    15c9:	8d a4 24 98 ef ff ff 	lea    -0x1068(%esp),%esp
    15d0:	83 0c 24 00          	orl    $0x0,(%esp)
    15d4:	8d a4 24 0c 10 00 00 	lea    0x100c(%esp),%esp
    15db:	e8 d0 f7 ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    15e0:	81 c3 70 29 00 00    	add    $0x2970,%ebx
    15e6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    15ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    15ef:	31 c0                	xor    %eax,%eax

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    15f1:	8b 83 dc d3 ff ff    	mov    -0x2c24(%ebx),%eax
    15f7:	89 45 b0             	mov    %eax,-0x50(%ebp)
    15fa:	8b 83 e0 d3 ff ff    	mov    -0x2c20(%ebx),%eax
    1600:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    1603:	8b 83 e4 d3 ff ff    	mov    -0x2c1c(%ebx),%eax
    1609:	89 45 b8             	mov    %eax,-0x48(%ebp)
    160c:	8b 83 e8 d3 ff ff    	mov    -0x2c18(%ebx),%eax
    1612:	89 45 bc             	mov    %eax,-0x44(%ebp)
    1615:	8b 83 ec d3 ff ff    	mov    -0x2c14(%ebx),%eax
    161b:	89 45 c0             	mov    %eax,-0x40(%ebp)
    161e:	8b 83 f0 d3 ff ff    	mov    -0x2c10(%ebx),%eax
    1624:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    1627:	8b 83 f4 d3 ff ff    	mov    -0x2c0c(%ebx),%eax
    162d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1630:	8b 83 f8 d3 ff ff    	mov    -0x2c08(%ebx),%eax
    1636:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1639:	8b 83 fc d3 ff ff    	mov    -0x2c04(%ebx),%eax
    163f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1642:	8b 83 00 d4 ff ff    	mov    -0x2c00(%ebx),%eax
    1648:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    164b:	8b 83 04 d4 ff ff    	mov    -0x2bfc(%ebx),%eax
    1651:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1654:	8b 83 08 d4 ff ff    	mov    -0x2bf8(%ebx),%eax
    165a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    165d:	8b 83 0c d4 ff ff    	mov    -0x2bf4(%ebx),%eax
    1663:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint8_t ret;

    ap = (uint8_t *)&f_int;

    memcpy(current_opcode, ap, OPCODE_LEN);
    if (memcmp(current_opcode, f_opcode, OPCODE_LEN) != 0) {
    1666:	6a 34                	push   $0x34
    1668:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
    166e:	50                   	push   %eax
    166f:	8d 45 b0             	lea    -0x50(%ebp),%eax
    1672:	50                   	push   %eax
    1673:	e8 c8 f5 ff ff       	call   c40 <memcmp@plt>
    1678:	83 c4 10             	add    $0x10,%esp
    167b:	85 c0                	test   %eax,%eax
    167d:	0f 84 eb 00 00 00    	je     176e <main+0x1b6>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
    1683:	83 ec 0c             	sub    $0xc,%esp
    1686:	8d 83 d0 df ff ff    	lea    -0x2030(%ebx),%eax
    168c:	50                   	push   %eax
    168d:	e8 0e f6 ff ff       	call   ca0 <puts@plt>
    1692:	83 c4 0c             	add    $0xc,%esp
    1695:	8d 83 dc d3 ff ff    	lea    -0x2c24(%ebx),%eax
    169b:	50                   	push   %eax
    169c:	8d 83 78 df ff ff    	lea    -0x2088(%ebx),%eax
    16a2:	50                   	push   %eax
    16a3:	6a 01                	push   $0x1
    16a5:	e8 86 f6 ff ff       	call   d30 <__printf_chk@plt>
        printf(" [!!] opcodes should be updated\r\n");
        printf("0x%p ", f_int);
        for (i=0;i<8;i++) {
    16aa:	83 c4 10             	add    $0x10,%esp
    16ad:	be 00 00 00 00       	mov    $0x0,%esi
    16b2:	eb 48                	jmp    16fc <main+0x144>
            printf("%02x%02x%02x%02x ", (uint8_t)(*(ap+4*i)), (uint8_t)(*(ap+4*i+1)), (uint8_t)*((ap+4*i+2)), (uint8_t)(*(ap+4*i+3)));
    16b4:	89 f0                	mov    %esi,%eax
    16b6:	0f b6 c0             	movzbl %al,%eax
    16b9:	c1 e0 02             	shl    $0x2,%eax
    16bc:	0f b6 bc 18 df d3 ff 	movzbl -0x2c21(%eax,%ebx,1),%edi
    16c3:	ff 
    16c4:	0f b6 8c 18 de d3 ff 	movzbl -0x2c22(%eax,%ebx,1),%ecx
    16cb:	ff 
    16cc:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
    16cf:	0f b6 8c 18 dd d3 ff 	movzbl -0x2c23(%eax,%ebx,1),%ecx
    16d6:	ff 
    16d7:	0f b6 84 18 dc d3 ff 	movzbl -0x2c24(%eax,%ebx,1),%eax
    16de:	ff 
    16df:	83 ec 08             	sub    $0x8,%esp
    16e2:	57                   	push   %edi
    16e3:	ff 75 a4             	pushl  -0x5c(%ebp)
    16e6:	51                   	push   %ecx
    16e7:	50                   	push   %eax
    16e8:	8d 83 7e df ff ff    	lea    -0x2082(%ebx),%eax
    16ee:	50                   	push   %eax
    16ef:	6a 01                	push   $0x1
    16f1:	e8 3a f6 ff ff       	call   d30 <__printf_chk@plt>
    16f6:	83 c4 20             	add    $0x20,%esp

    memcpy(current_opcode, ap, OPCODE_LEN);
    if (memcmp(current_opcode, f_opcode, OPCODE_LEN) != 0) {
        printf(" [!!] opcodes should be updated\r\n");
        printf("0x%p ", f_int);
        for (i=0;i<8;i++) {
    16f9:	83 c6 01             	add    $0x1,%esi
    16fc:	89 f0                	mov    %esi,%eax
    16fe:	3c 07                	cmp    $0x7,%al
    1700:	76 b2                	jbe    16b4 <main+0xfc>
    1702:	83 ec 04             	sub    $0x4,%esp
    1705:	6a 34                	push   $0x34
    1707:	8d 83 90 df ff ff    	lea    -0x2070(%ebx),%eax
    170d:	50                   	push   %eax
    170e:	6a 01                	push   $0x1
    1710:	e8 1b f6 ff ff       	call   d30 <__printf_chk@plt>
            printf("%02x%02x%02x%02x ", (uint8_t)(*(ap+4*i)), (uint8_t)(*(ap+4*i+1)), (uint8_t)*((ap+4*i+2)), (uint8_t)(*(ap+4*i+3)));
        }
        printf("\r\nuint8_t f_opcode[%d] = {", OPCODE_LEN);
        for (i=0; i<OPCODE_LEN; i++) {
    1715:	83 c4 10             	add    $0x10,%esp
    1718:	be 00 00 00 00       	mov    $0x0,%esi
    171d:	eb 37                	jmp    1756 <main+0x19e>
            printf("0x%02x%s", (uint8_t)(*(ap+i)), i < (OPCODE_LEN-1) ? ", ":"");
    171f:	89 f0                	mov    %esi,%eax
    1721:	3c 32                	cmp    $0x32,%al
    1723:	77 08                	ja     172d <main+0x175>
    1725:	8d 93 75 df ff ff    	lea    -0x208b(%ebx),%edx
    172b:	eb 06                	jmp    1733 <main+0x17b>
    172d:	8d 93 ce df ff ff    	lea    -0x2032(%ebx),%edx
    1733:	89 f0                	mov    %esi,%eax
    1735:	0f b6 c0             	movzbl %al,%eax
    1738:	0f b6 84 03 dc d3 ff 	movzbl -0x2c24(%ebx,%eax,1),%eax
    173f:	ff 
    1740:	52                   	push   %edx
    1741:	50                   	push   %eax
    1742:	8d 83 ab df ff ff    	lea    -0x2055(%ebx),%eax
    1748:	50                   	push   %eax
    1749:	6a 01                	push   $0x1
    174b:	e8 e0 f5 ff ff       	call   d30 <__printf_chk@plt>
    1750:	83 c4 10             	add    $0x10,%esp
        printf("0x%p ", f_int);
        for (i=0;i<8;i++) {
            printf("%02x%02x%02x%02x ", (uint8_t)(*(ap+4*i)), (uint8_t)(*(ap+4*i+1)), (uint8_t)*((ap+4*i+2)), (uint8_t)(*(ap+4*i+3)));
        }
        printf("\r\nuint8_t f_opcode[%d] = {", OPCODE_LEN);
        for (i=0; i<OPCODE_LEN; i++) {
    1753:	83 c6 01             	add    $0x1,%esi
    1756:	89 f0                	mov    %esi,%eax
    1758:	3c 33                	cmp    $0x33,%al
    175a:	76 c3                	jbe    171f <main+0x167>
    175c:	83 ec 0c             	sub    $0xc,%esp
    175f:	8d 83 b4 df ff ff    	lea    -0x204c(%ebx),%eax
    1765:	50                   	push   %eax
    1766:	e8 35 f5 ff ff       	call   ca0 <puts@plt>
    176b:	83 c4 10             	add    $0x10,%esp
    176e:	83 ec 04             	sub    $0x4,%esp
    1771:	8d 83 dc d3 ff ff    	lea    -0x2c24(%ebx),%eax
    1777:	50                   	push   %eax
    1778:	8d 83 f4 df ff ff    	lea    -0x200c(%ebx),%eax
    177e:	50                   	push   %eax
    177f:	6a 01                	push   $0x1
    1781:	e8 aa f5 ff ff       	call   d30 <__printf_chk@plt>
        printf("};\r\n");
    }

#ifdef SCENARIO1
    printf("* execute internal function from %p", f_int);
    ret = f_int();
    1786:	e8 a1 fb ff ff       	call   132c <f_int>
    if (ret == 0xee) {
    178b:	83 c4 10             	add    $0x10,%esp
    178e:	3c ee                	cmp    $0xee,%al
    1790:	75 14                	jne    17a6 <main+0x1ee>
    1792:	83 ec 0c             	sub    $0xc,%esp
    1795:	8d 83 b8 df ff ff    	lea    -0x2048(%ebx),%eax
    179b:	50                   	push   %eax
    179c:	e8 ff f4 ff ff       	call   ca0 <puts@plt>
    17a1:	83 c4 10             	add    $0x10,%esp
    17a4:	eb 18                	jmp    17be <main+0x206>
        printf(" \t[ok]\r\n");
    } else {
        printf(", ret 0x%02x\r\n", ret);
    17a6:	0f b6 c0             	movzbl %al,%eax
    17a9:	83 ec 04             	sub    $0x4,%esp
    17ac:	50                   	push   %eax
    17ad:	8d 83 c0 df ff ff    	lea    -0x2040(%ebx),%eax
    17b3:	50                   	push   %eax
    17b4:	6a 01                	push   $0x1
    17b6:	e8 75 f5 ff ff       	call   d30 <__printf_chk@plt>
    17bb:	83 c4 10             	add    $0x10,%esp
    17be:	83 ec 04             	sub    $0x4,%esp
    17c1:	8d b3 d0 00 00 00    	lea    0xd0(%ebx),%esi
    17c7:	56                   	push   %esi
    17c8:	8d 83 18 e0 ff ff    	lea    -0x1fe8(%ebx),%eax
    17ce:	50                   	push   %eax
    17cf:	6a 01                	push   $0x1
    17d1:	e8 5a f5 ff ff       	call   d30 <__printf_chk@plt>
    }
#endif

#ifdef SCENARIO2
    printf("* execute stored opcodes via mmap obeying NX %p", f_opcode);
    ret = exec_opcode(f_opcode, sizeof(f_opcode));
    17d6:	83 c4 08             	add    $0x8,%esp
    17d9:	6a 34                	push   $0x34
    17db:	56                   	push   %esi
    17dc:	e8 84 fb ff ff       	call   1365 <exec_opcode>
    if (ret == 0xee) {
    17e1:	83 c4 10             	add    $0x10,%esp
    17e4:	3c ee                	cmp    $0xee,%al
    17e6:	75 14                	jne    17fc <main+0x244>
    17e8:	83 ec 0c             	sub    $0xc,%esp
    17eb:	8d 83 b8 df ff ff    	lea    -0x2048(%ebx),%eax
    17f1:	50                   	push   %eax
    17f2:	e8 a9 f4 ff ff       	call   ca0 <puts@plt>
    17f7:	83 c4 10             	add    $0x10,%esp
    17fa:	eb 18                	jmp    1814 <main+0x25c>
        printf(" \t[ok]\r\n");
    } else {
        printf(", ret 0x%02x\r\n", ret);
    17fc:	0f b6 c0             	movzbl %al,%eax
    17ff:	83 ec 04             	sub    $0x4,%esp
    1802:	50                   	push   %eax
    1803:	8d 83 c0 df ff ff    	lea    -0x2040(%ebx),%eax
    1809:	50                   	push   %eax
    180a:	6a 01                	push   $0x1
    180c:	e8 1f f5 ff ff       	call   d30 <__printf_chk@plt>
    1811:	83 c4 10             	add    $0x10,%esp
    1814:	83 ec 04             	sub    $0x4,%esp
    1817:	8d 75 b0             	lea    -0x50(%ebp),%esi
    181a:	56                   	push   %esi
    181b:	8d 83 48 e0 ff ff    	lea    -0x1fb8(%ebx),%eax
    1821:	50                   	push   %eax
    1822:	6a 01                	push   $0x1
    1824:	e8 07 f5 ff ff       	call   d30 <__printf_chk@plt>
    }
#endif

#ifdef SCENARIO3
    printf("* execute detected opcodes via mmap obeying NX %p", current_opcode);
    ret = exec_opcode(current_opcode, sizeof(f_opcode));
    1829:	83 c4 08             	add    $0x8,%esp
    182c:	6a 34                	push   $0x34
    182e:	56                   	push   %esi
    182f:	e8 31 fb ff ff       	call   1365 <exec_opcode>
    if (ret == 0xee) {
    1834:	83 c4 10             	add    $0x10,%esp
    1837:	3c ee                	cmp    $0xee,%al
    1839:	75 14                	jne    184f <main+0x297>
    183b:	83 ec 0c             	sub    $0xc,%esp
    183e:	8d 83 b8 df ff ff    	lea    -0x2048(%ebx),%eax
    1844:	50                   	push   %eax
    1845:	e8 56 f4 ff ff       	call   ca0 <puts@plt>
    184a:	83 c4 10             	add    $0x10,%esp
    184d:	eb 18                	jmp    1867 <main+0x2af>
        printf(" \t[ok]\r\n");
    } else {
        printf(", ret 0x%02x\r\n", ret);
    184f:	0f b6 c0             	movzbl %al,%eax
    1852:	83 ec 04             	sub    $0x4,%esp
    1855:	50                   	push   %eax
    1856:	8d 83 c0 df ff ff    	lea    -0x2040(%ebx),%eax
    185c:	50                   	push   %eax
    185d:	6a 01                	push   $0x1
    185f:	e8 cc f4 ff ff       	call   d30 <__printf_chk@plt>
    1864:	83 c4 10             	add    $0x10,%esp
    1867:	83 ec 04             	sub    $0x4,%esp
    186a:	8d 75 b0             	lea    -0x50(%ebp),%esi
    186d:	56                   	push   %esi
    186e:	8d 83 7c e0 ff ff    	lea    -0x1f84(%ebx),%eax
    1874:	50                   	push   %eax
    1875:	6a 01                	push   $0x1
    1877:	e8 b4 f4 ff ff       	call   d30 <__printf_chk@plt>
    }
#endif

#ifdef SCENARIO4
    printf("* execute detected opcodes via mmap not obeying NX %p", current_opcode);
    ret = exec_opcode_WX(current_opcode, sizeof(f_opcode));
    187c:	83 c4 08             	add    $0x8,%esp
    187f:	6a 34                	push   $0x34
    1881:	56                   	push   %esi
    1882:	e8 02 fc ff ff       	call   1489 <exec_opcode_WX>
    if (ret == 0xee) {
    1887:	83 c4 10             	add    $0x10,%esp
    188a:	3c ee                	cmp    $0xee,%al
    188c:	75 14                	jne    18a2 <main+0x2ea>
    188e:	83 ec 0c             	sub    $0xc,%esp
    1891:	8d 83 b8 df ff ff    	lea    -0x2048(%ebx),%eax
    1897:	50                   	push   %eax
    1898:	e8 03 f4 ff ff       	call   ca0 <puts@plt>
    189d:	83 c4 10             	add    $0x10,%esp
    18a0:	eb 18                	jmp    18ba <main+0x302>
        printf(" \t[ok]\r\n");
    } else {
        printf(", ret 0x%02x\r\n", ret);
    18a2:	0f b6 c0             	movzbl %al,%eax
    18a5:	83 ec 04             	sub    $0x4,%esp
    18a8:	50                   	push   %eax
    18a9:	8d 83 c0 df ff ff    	lea    -0x2040(%ebx),%eax
    18af:	50                   	push   %eax
    18b0:	6a 01                	push   $0x1
    18b2:	e8 79 f4 ff ff       	call   d30 <__printf_chk@plt>
    18b7:	83 c4 10             	add    $0x10,%esp
    18ba:	83 ec 04             	sub    $0x4,%esp
    18bd:	8d 75 b0             	lea    -0x50(%ebp),%esi
    18c0:	56                   	push   %esi
    18c1:	8d 83 b4 e0 ff ff    	lea    -0x1f4c(%ebx),%eax
    18c7:	50                   	push   %eax
    18c8:	6a 01                	push   $0x1
    18ca:	e8 61 f4 ff ff       	call   d30 <__printf_chk@plt>
    }
#endif

#ifdef SCENARIO5
    printf("* execute detected opcodes without mmap, also not obeying NX %p", current_opcode);
    ret = exec_opcode_no_mmap(current_opcode, sizeof(f_opcode));
    18cf:	83 c4 08             	add    $0x8,%esp
    18d2:	6a 34                	push   $0x34
    18d4:	56                   	push   %esi
    18d5:	e8 a8 fc ff ff       	call   1582 <exec_opcode_no_mmap>
    if (ret == 0xee) {
    18da:	83 c4 10             	add    $0x10,%esp
    18dd:	3c ee                	cmp    $0xee,%al
    18df:	75 14                	jne    18f5 <main+0x33d>
    18e1:	83 ec 0c             	sub    $0xc,%esp
    18e4:	8d 83 b8 df ff ff    	lea    -0x2048(%ebx),%eax
    18ea:	50                   	push   %eax
    18eb:	e8 b0 f3 ff ff       	call   ca0 <puts@plt>
    18f0:	83 c4 10             	add    $0x10,%esp
    18f3:	eb 18                	jmp    190d <main+0x355>
        printf(" \t[ok]\r\n");
    } else {
        printf(", ret 0x%02x\r\n", ret);
    18f5:	0f b6 c0             	movzbl %al,%eax
    18f8:	83 ec 04             	sub    $0x4,%esp
    18fb:	50                   	push   %eax
    18fc:	8d 83 c0 df ff ff    	lea    -0x2040(%ebx),%eax
    1902:	50                   	push   %eax
    1903:	6a 01                	push   $0x1
    1905:	e8 26 f4 ff ff       	call   d30 <__printf_chk@plt>
    190a:	83 c4 10             	add    $0x10,%esp
    }
#endif

	return EXIT_SUCCESS;
}
    190d:	b8 00 00 00 00       	mov    $0x0,%eax
    1912:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    1915:	65 33 3d 14 00 00 00 	xor    %gs:0x14,%edi
    191c:	74 05                	je     1923 <main+0x36b>
    191e:	e8 8d 00 00 00       	call   19b0 <__stack_chk_fail_local>
    1923:	8d 65 f0             	lea    -0x10(%ebp),%esp
    1926:	59                   	pop    %ecx
    1927:	5b                   	pop    %ebx
    1928:	5e                   	pop    %esi
    1929:	5f                   	pop    %edi
    192a:	5d                   	pop    %ebp
    192b:	8d 61 fc             	lea    -0x4(%ecx),%esp
    192e:	c3                   	ret    
    192f:	90                   	nop

00001930 <__libc_csu_init>:
    1930:	55                   	push   %ebp
    1931:	89 e5                	mov    %esp,%ebp
    1933:	57                   	push   %edi
    1934:	56                   	push   %esi
    1935:	53                   	push   %ebx
    1936:	81 ec 1c 10 00 00    	sub    $0x101c,%esp
    193c:	83 0c 24 00          	orl    $0x0,(%esp)
    1940:	81 c4 10 10 00 00    	add    $0x1010,%esp
    1946:	e8 65 f4 ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    194b:	81 c3 05 26 00 00    	add    $0x2605,%ebx
    1951:	31 ff                	xor    %edi,%edi
    1953:	e8 54 f2 ff ff       	call   bac <_init>
    1958:	8d b3 e8 fc ff ff    	lea    -0x318(%ebx),%esi
    195e:	8d 83 e4 fc ff ff    	lea    -0x31c(%ebx),%eax
    1964:	29 c6                	sub    %eax,%esi
    1966:	c1 fe 02             	sar    $0x2,%esi
    1969:	85 f6                	test   %esi,%esi
    196b:	74 20                	je     198d <__libc_csu_init+0x5d>
    196d:	8d 76 00             	lea    0x0(%esi),%esi
    1970:	83 ec 04             	sub    $0x4,%esp
    1973:	ff 75 10             	pushl  0x10(%ebp)
    1976:	ff 75 0c             	pushl  0xc(%ebp)
    1979:	ff 75 08             	pushl  0x8(%ebp)
    197c:	ff 94 bb e4 fc ff ff 	call   *-0x31c(%ebx,%edi,4)
    1983:	83 c7 01             	add    $0x1,%edi
    1986:	83 c4 10             	add    $0x10,%esp
    1989:	39 f7                	cmp    %esi,%edi
    198b:	75 e3                	jne    1970 <__libc_csu_init+0x40>
    198d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1990:	5b                   	pop    %ebx
    1991:	5e                   	pop    %esi
    1992:	5f                   	pop    %edi
    1993:	5d                   	pop    %ebp
    1994:	c3                   	ret    
    1995:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019a0 <__libc_csu_fini>:
    19a0:	55                   	push   %ebp
    19a1:	89 e5                	mov    %esp,%ebp
    19a3:	5d                   	pop    %ebp
    19a4:	c3                   	ret    
    19a5:	66 90                	xchg   %ax,%ax
    19a7:	66 90                	xchg   %ax,%ax
    19a9:	66 90                	xchg   %ax,%ax
    19ab:	66 90                	xchg   %ax,%ax
    19ad:	66 90                	xchg   %ax,%ax
    19af:	90                   	nop

000019b0 <__stack_chk_fail_local>:
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	53                   	push   %ebx
    19b4:	81 ec 14 10 00 00    	sub    $0x1014,%esp
    19ba:	83 0c 24 00          	orl    $0x0,(%esp)
    19be:	81 c4 10 10 00 00    	add    $0x1010,%esp
    19c4:	e8 e7 f3 ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    19c9:	81 c3 87 25 00 00    	add    $0x2587,%ebx
    19cf:	e8 7c f2 ff ff       	call   c50 <__stack_chk_fail@plt>

Disassembly of section .fini:

000019d4 <_fini>:
    19d4:	53                   	push   %ebx
    19d5:	83 ec 08             	sub    $0x8,%esp
    19d8:	e8 d3 f3 ff ff       	call   db0 <__x86.get_pc_thunk.bx>
    19dd:	81 c3 73 25 00 00    	add    $0x2573,%ebx
    19e3:	83 c4 08             	add    $0x8,%esp
    19e6:	5b                   	pop    %ebx
    19e7:	c3                   	ret    
